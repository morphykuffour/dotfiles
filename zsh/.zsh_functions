#!/usr/bin/env sh

# -------------------------------- FUNCTIONS ---------------------------------

# Function to source files if they exist
zsh_add_file() {
    [ -f "$ZDOTDIR/$1" ] && source "$ZDOTDIR/$1"
}

# neovim-docker
dv () {
	sudo docker run \
	-it -v `pwd`:/mnt/volume\
        -v $HOME/.config/nvim:/home/neovim/.config/nvim \
	--workdir=/mnt/volume \
	anatolelucet/neovim:stable \
        "$@"
}

# Bash Function To Extract File Archives Of Various Types
extract () {
     if [ -f $1 ] ; then
         case $1 in
             *.tar.bz2)   tar xjf $1     ;;
             *.tar.gz)    tar xzf $1     ;;
             *.tar.xz)    tar xf  $1     ;;
             *.bz2)       bunzip2 $1     ;;
             *.rar)       rar x   $1     ;;
             *.gz)        gunzip  $1     ;;
             *.tar)       tar xf  $1     ;;
             *.tbz2)      tar xjf $1     ;;
             *.tgz)       tar xzf $1     ;;
             *.zip)       unzip   $1     ;;
             *.Z)         uncompress $1  ;;
             *.7z)        7z x $1    ;;
             *)           echo "'$1' cannot be extracted via extract()" ;;
         esac
     else
         echo "'$1' is not a valid file"
     fi
}

zsh_add_plugin() {
  PLUGIN_NAME=$(basename "$1" | cut -f 1 -d '.')
    if [ -d "$ZDOTDIR/plugins/$PLUGIN_NAME" ]; then 
        # For plugins
        zsh_add_file "plugins/$PLUGIN_NAME/$PLUGIN_NAME.plugin.zsh" || \
        zsh_add_file "plugins/$PLUGIN_NAME/$PLUGIN_NAME.zsh"
    else
        git clone $1 "$ZDOTDIR/plugins/$PLUGIN_NAME"
    fi
}

# ranger change dir
ranger-cd() {
    tmp="$(mktemp)"
    ranger --choosedir="$tmp" "$@"
    if [ -f "$tmp" ]; then
        dir="$(cat "$tmp")"
        rm -f "$tmp"
        if [ -d "$dir" ]; then
            if [ "$dir" != "$(pwd)" ]; then
                cd "$dir"
            fi
        fi
    fi
}
#
alias rcd=ranger-cd
bindkey -s '^o' 'rcd\n'

# Use lf to switch directories and bind it to ctrl-o
lfcd () {
    tmp="$(mktemp)"
    lf -last-dir-path="$tmp" "$@"
    if [ -f "$tmp" ]; then
        dir="$(cat "$tmp")"
        rm -f "$tmp" >/dev/null
        [ -d "$dir" ] && [ "$dir" != "$(pwd)" ] && cd "$dir" || exit
    fi
}
# bindkey -s '^o' 'lfcd\n'

# Top ten memory hogs
# http://www.commandlinefu.com/commands/view/7139/top-ten-memory-hogs
memtop() {
  ps -eorss,args | gsort -nr | gpr -TW$COLUMNS | ghead
}
zle -N memtop

change_background() {
    feh --randomize --bg-scale --no-xinerama $HOME/Pictures/wallpapers/$(ls $HOME/Pictures/wallpapers | fzf --preview 'sxiv {}')
}

myip () {
  curl ifconfig.me
}

# strg+x,s adds sudo to the line
run_with_sudo() {
  LBUFFER="sudo $LBUFFER"
}
zle -N run-with-sudo
bindkey '^Xs' run-with-sudo

die () {
    echo >&2 "$@"
    exit 1
}

addToPath() {
    if [[ "$PATH" != *"$1"* ]]; then
        export PATH=$PATH:$1
    fi
}

addToPathFront() {
    if [[ "$PATH" != *"$1"* ]]; then
        export PATH=$1:$PATH
    fi
}

# create a new script, automatically populating the shebang line, editing the script, and making it executable.
shebang() {
# $ shebang perl test.pl
    if i=$(which $1);
    then
        printf '#!/usr/bin/env %s\n\n' $1 > $2 && chmod 755 $2 && vim + $2 && chmod 755 $2;
    else
        echo "'which' could not find $1, is it in your \$PATH?";
    fi;
    rehash
}

commitDotFiles() {
    cd "$HOME"/dotfiles || exit
    git add .
    git commit 
    # git push 
}

mkd() {
  if [ -z "$1" ]; then
    echo "Enter a directory name"
  elif [ -d "$1" ]; then
    echo "\`$1' already exists"
  else
    mkdir "$1" && cd "$1" || exit
  fi
}


# histdb
# _zsh_autosuggest_strategy_histdb_top_here() {
#     local query="select commands.argv from
# history left join commands on history.command_id = commands.rowid
# left join places on history.place_id = places.rowid
# where places.dir LIKE '$(sql_escape $PWD)%'
# and commands.argv LIKE '$(sql_escape $1)%'
# group by commands.argv order by count(*) desc limit 1"
#     suggestion=$(_histdb_query "$query")
# }
# 
# ZSH_AUTOSUGGEST_STRATEGY=histdb_top_here
# 
# _zsh_autosuggest_strategy_histdb_top() {
#     local query="
#         select commands.argv from history
#         left join commands on history.command_id = commands.rowid
#         left join places on history.place_id = places.rowid
#         where commands.argv LIKE '$(sql_escape $1)%'
#         group by commands.argv, places.dir
#         order by places.dir != '$(sql_escape $PWD)', count(*) desc
#         limit 1
#     "
#     suggestion=$(_histdb_query "$query")
# }
# 
# ZSH_AUTOSUGGEST_STRATEGY=histdb_top
# 
# 
